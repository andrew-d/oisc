#include <stdio.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdlib.h>

/* #define TRACE */

int32_t code[] = {
	696, 696, 4, 9, 3, 696, 7, 696, 184, 10,
	696, 696, 13, 696, 696, 17, 19, 696, 696, 22,
	0, 0, 20, 20, 25, 16, 696, 28, 696, 20,
	31, 696, 696, 34, 21, 21, 37, 184, 696, 40,
	696, 21, 43, 696, 696, 46, 184, 184, 49, 696,
	20, 55, 696, 696, 61, 20, 696, 80, 696, 696,
	61, 21, 696, 64, 696, 184, 67, 696, 696, 70,
	696, 696, 74, 1, 73, 20, 77, 696, 696, 49,
	696, 696, 83, 696, 696, 87, 10, 687, 687, 90,
	696, 185, 696, 696, 185, 696, 696, 110, 0, 0,
	108, 108, 113, 689, 696, 116, 696, 108, 119, 696,
	696, 122, 109, 109, 125, 688, 696, 128, 696, 109,
	131, 696, 696, 134, 688, 688, 137, 696, 108, 143,
	696, 696, 149, 108, 696, 168, 696, 696, 149, 109,
	696, 152, 696, 688, 155, 696, 696, 158, 696, 696,
	162, 1, 161, 108, 165, 696, 696, 137, 696, 696,
	171, 687, 696, 174, 696, 688, 177, 696, 696, 180,
	696, 696, 87, 40, 0, 696, 696, 190, 0, 0,
	188, 188, 193, 86, 696, 196, 696, 188, 199, 696,
	696, 202, 189, 189, 205, 183, 696, 208, 696, 189,
	211, 696, 696, 214, 183, 183, 217, 696, 188, 223,
	696, 696, 229, 188, 696, 248, 696, 696, 229, 189,
	696, 232, 696, 183, 235, 696, 696, 238, 696, 696,
	242, 1, 241, 188, 245, 696, 696, 217, 696, 696,
	251, 696, 696, 256, 0, 0, 254, 254, 259, 86,
	696, 262, 696, 254, 265, 696, 696, 268, 255, 255,
	271, 183, 696, 274, 696, 255, 277, 696, 696, 280,
	183, 183, 283, 696, 254, 289, 696, 696, 295, 254,
	696, 314, 696, 696, 295, 255, 696, 298, 696, 183,
	301, 696, 696, 304, 696, 696, 308, 1, 307, 254,
	311, 696, 696, 283, 696, 696, 317, 696, 696, 321,
	1, 320, 696, 324, 696, 183, 327, 696, 696, 330,
	696, 696, 335, 0, 0, 333, 333, 338, 183, 696,
	341, 696, 333, 344, 696, 696, 347, 334, 334, 350,
	184, 696, 353, 696, 334, 356, 696, 696, 359, 184,
	184, 362, 696, 333, 368, 696, 696, 374, 333, 696,
	393, 696, 696, 374, 334, 696, 377, 696, 184, 380,
	696, 696, 383, 696, 696, 387, 1, 386, 333, 390,
	696, 696, 362, 696, 696, 396, 183, 183, 399, 696,
	696, 403, 44, 402, 696, 406, 696, 183, 409, 696,
	696, 412, 696, 696, 417, 0, 0, 415, 415, 420,
	86, 696, 423, 696, 415, 426, 696, 696, 429, 416,
	416, 432, 183, 696, 435, 696, 416, 438, 696, 696,
	441, 183, 183, 444, 696, 415, 450, 696, 696, 456,
	415, 696, 475, 696, 696, 456, 416, 696, 459, 696,
	183, 462, 696, 696, 465, 696, 696, 469, 1, 468,
	415, 472, 696, 696, 444, 696, 696, 478, 696, 696,
	483, 0, 0, 481, 481, 486, 86, 696, 489, 696,
	481, 492, 696, 696, 495, 482, 482, 498, 183, 696,
	501, 696, 482, 504, 696, 696, 507, 183, 183, 510,
	696, 481, 516, 696, 696, 522, 481, 696, 541, 696,
	696, 522, 482, 696, 525, 696, 183, 528, 696, 696,
	531, 696, 696, 535, 1, 534, 481, 538, 696, 696,
	510, 696, 696, 544, 696, 696, 548, 23, 547, 696,
	551, 696, 183, 554, 696, 696, 557, 696, 696, 562,
	0, 0, 560, 560, 565, 183, 696, 568, 696, 560,
	571, 696, 696, 574, 561, 561, 577, 184, 696, 580,
	696, 561, 583, 696, 696, 586, 184, 184, 589, 696,
	560, 595, 696, 696, 601, 560, 696, 620, 696, 696,
	601, 561, 696, 604, 696, 184, 607, 696, 696, 610,
	696, 696, 614, 1, 613, 560, 617, 696, 696, 589,
	696, 696, 623, 184, 688, 626, 696, 688, 632, 696,
	696, 684, 688, 696, 638, 696, 696, 684, 687, 687,
	641, 690, 696, 644, 696, 687, 647, 696, 696, 650,
	696, 687, 656, 696, 696, 662, 687, 696, 681, 696,
	696, 662, 687, -1, 665, 696, 696, 669, 1, 668,
	696, 672, 696, 641, 675, 696, 696, 678, 696, 696,
	638, 696, 696, 684, 696, 696, -1, 0, 0, 31,
	71, 111, 111, 100, 10, 0, 0,
};

int32_t start = 0;



#define MEMORY_SIZE  ((int32_t)(sizeof(code) / sizeof(code[0])))


void die(const char * format, ...)
{
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);

    fprintf(stderr, "\n");
    fflush(stderr);
    exit(1);
}

int main(void) {
    int32_t ip = start;
    int32_t a, b, c;
    int32_t existing, new;
#ifdef TRACE
    uint32_t count = 0;
#endif

    while( ip >= 0 ) {
        /* Bounds check.  It might overflow ... but if you're
         * doing that much emulation, there are bigger problems.
         */
        if( (ip + 2) >= MEMORY_SIZE ) {
            die("IP ran past end of array (%d)", ip);
        }

        /* Read instruction. */
        a = code[ip + 0];
        b = code[ip + 1];
        c = code[ip + 2];

#ifdef TRACE
        fprintf(stderr, "[vm] %d: %d %d %d\n", ip, a, b, c);
#endif

        /* Bounds check. */
        if( b >= MEMORY_SIZE ) {
            die("Bad operand %d at %d", b, ip);
        }
        if( c >= MEMORY_SIZE ) {
            die("Bad operand %d at %d", c, ip);
        }

        /* Perform subtraction.  Note that a read of -1 here should read a
         * single character from stdin, and a write to -1 should write that
         * character to stdout.  For the initial read, we just have negative
         * reads return 0.
         */
        if( b < 0 ) {
            existing = 0;
        } else {
            existing = code[b];
        }

        if( a < 0 ) {
            new = -getchar();
        } else {
            new = code[a];
        }
        new = existing - new;

        if( b < 0 ) {
            putchar(-new);
        } else {
            code[b] = new;
        }

#ifdef TRACE
        fprintf(stderr, "[vm]     mem[%d] = %d --> %d\n", b, existing, new);
#endif

        /* Branch. */
        if( new <= 0 ) {
            ip = c;
        } else {
            ip += 3;
        }

#ifdef TRACE
        count++;
#endif
    }

#ifdef TRACE
    fprintf(stderr, "[vm] Ran %d instructions\n", count);
#endif

    return 0;
}
